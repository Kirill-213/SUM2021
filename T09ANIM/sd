#include <string.h>

#include "anim.h"
#include <mmsystem.h>
#pragma comment(lib, "winmm")

#define ND4_GET_JOYSTIC_AXIS(A) \
   (2.0 * (ji.dw ## A ## pos - jc.w ## A ## min) / (jc.w ## A ## max - jc.w ## A ## min) - 1)

/* Mouse wheel state global data */
INT ND4_MouseWheel;

/* Keyboard initialization function.
 * ARGUMENTS:
 *   - None.
 * RETURNS:
 *   (VOID) None.
*/
static VOID ND4_AnimKeyboardInit( VOID )
{
  INT i;

  for (i = 0; i < 256; i++)
  {
    ND4_Anim.Keys[i] = 0;
    ND4_Anim.KeysClick[i] = 0;
    ND4_Anim.KeysOld[i] = 0;
  }
} /* End of 'ND4_AnimKeyboardInit' function */

/* Keyboard response function.
 * ARGUMENTS:
 *   - None.
 * RETURNS:
 *   (VOID) None.
*/
static VOID ND4_AnimKeyboardResponse( VOID )
{
  INT i;

  GetKeyboardState(ND4_Anim.Keys);
  for (i = 0; i < 256; i++)
  {
    ND4_Anim.Keys[i] >>= 7;
    ND4_Anim.KeysClick[i] = ND4_Anim.Keys[i] && !ND4_Anim.KeysOld[i];
  }

  memcpy(ND4_Anim.KeysOld, ND4_Anim.Keys, 256);
} /* End of 'ND4_AnimKeyboardResponse' function */

/* Mouse initialization function.
 * ARGUMENTS:
 *   - None.
 * RETURNS:
 *   (VOID) None.
*/
static VOID ND4_AnimMouseInit( VOID )
{
  POINT pt;

  GetCursorPos(&pt);
  ScreenToClient(ND4_Anim.hWnd, &pt);

  ND4_Anim.Mdx = pt.x - ND4_Anim.Mx;
  ND4_Anim.Mdy = pt.y - ND4_Anim.My;

  ND4_Anim.Mx = pt.x;
  ND4_Anim.My = pt.y;

  ND4_Anim.Mdz = ND4_MouseWheel;
  ND4_Anim.Mz += ND4_MouseWheel;
  ND4_MouseWheel = 0;
} /* End of 'ND4_AnimMouseInit' function */

/* Mouse response function.
 * ARGUMENTS:
 *   - None.
 * RETURNS:
 *   (VOID) None.
*/
static VOID ND4_AnimMouseResponse( VOID )
{
  POINT pt;

  GetCursorPos(&pt);
  ScreenToClient(ND4_Anim.hWnd, &pt);

  ND4_Anim.Mdx = pt.x - ND4_Anim.Mx;
  ND4_Anim.Mdy = pt.y - ND4_Anim.My;

  ND4_Anim.Mx = pt.x;
  ND4_Anim.My = pt.y;

  ND4_Anim.Mdz = ND4_MouseWheel;
  ND4_Anim.Mz += ND4_MouseWheel;
  ND4_MouseWheel = 0;
} /* End of 'ND4_AnimMouseResponse' function */

/* Joystick initialization function.
 * ARGUMENTS:
 *   - None.
 * RETURNS:

 *   (VOID) None.
*/
static VOID ND4_AnimJoystickInit( VOID )
{
  INT i;

  for (i = 0; i < 32; i++)
  {
    ND4_Anim.JBut[i] = 0;
    ND4_Anim.JButClick[i] = 0;
    ND4_Anim.JButOld[i] = 0;
  }

  /* Axes */
  ND4_Anim.JX = 0;
  ND4_Anim.JY = 0;
  ND4_Anim.JZ = 0;
  ND4_Anim.JR = 0;

  /* Point of view */
  ND4_Anim.JPov = 0;
} /* End of 'ND4_AnimJoystickInit' function */

/* Joystick response function.
 * ARGUMENTS:
 *   - None.
 * RETURNS:
 *   (VOID) None.
*/
static VOID ND4_AnimJoystickResponse( VOID )
{
  INT i;

  /* Joystick */
  if (joyGetNumDevs() > 0)
  {
    JOYCAPS jc;


    /* Get joystick info */
    if (joyGetDevCaps(JOYSTICKID1, &jc, sizeof(jc)) == JOYERR_NOERROR)
    {
      JOYINFOEX ji;


      ji.dwSize = sizeof(JOYINFOEX);
      ji.dwFlags = JOY_RETURNALL;
      if (joyGetPosEx(JOYSTICKID1, &ji) == JOYERR_NOERROR)
      {
        /* Buttons */
        for (i = 0; i < 32; i++)
        {
          ND4_Anim.JBut[i] = (ji.dwButtons >> i) & 1;
          ND4_Anim.JButClick[i] = ND4_Anim.JBut[i] && !ND4_Anim.JButOld[i];
          ND4_Anim.JButOld[i] = ND4_Anim.JBut[i];
        }
        /* Axes */
        ND4_Anim.JX = ND4_GET_JOYSTIC_AXIS(X);
        ND4_Anim.JY = ND4_GET_JOYSTIC_AXIS(Y);
        ND4_Anim.JZ = ND4_GET_JOYSTIC_AXIS(Z);
        ND4_Anim.JR = ND4_GET_JOYSTIC_AXIS(R);
        /* Point of view */
        ND4_Anim.JPov = ji.dwPOV == 0xFFFF ? -1 : ji.dwPOV / 4500;
      }
    }
  }
} /* End of 'ND4_AnimJoystickResponse' function */

/* Input initialization function.
 * ARGUMENTS:
 *   - None.
 * RETURNS:
 *   (VOID) None.
*/
VOID ND4_AnimInputInit( VOID )
{
  ND4_AnimKeyboardInit();
  ND4_AnimMouseInit();
  ND4_AnimJoystickInit();
} /* End of 'ND4_AnimInputInit' function */

/* Input response function.
 * ARGUMENTS:
 *   - None.
 * RETURNS:
 *   (VOID) None.
*/
VOID ND4_AnimInputResponse( VOID )
{
  ND4_AnimKeyboardResponse();
  ND4_AnimMouseResponse();
  ND4_AnimJoystickResponse();
} /* End of 'ND4_AnimInputResponse' function */

/* END OF 'input.c' FILE*/

/* FILE NAME : unit_ctrl.c
 * PROGRAMMER: ND4
 * DATE      : 21.06.2021 
 * PURPOSE   : Ctrl unit module
 */
#include <stdio.h>

#include "units.h"

typedef struct tagnd4UNIT_CTRL
{
  UNIT_BASE_FIELDS;
  VEC CamLoc;
  VEC Dir;
  VEC Right;
  INT Speed;
  DBL AngleSpeed;

  VEC At;
} nd4UNIT_CTRL;

/* Ctrl unit initialization function.
 * ARGUMENTS:
 *   - self-pointer to unit object:
 *       nd4UNIT_CTRL *Uni;
 *   - animation context:
 *       nd4ANIM *Ani;
 * RETURNS: None.
 */
static VOID ND4_UnitInit( nd4UNIT_CTRL *Uni, nd4ANIM *Ani )
{
  Uni->CamLoc = VecSet(0, 3, 10);
  Uni->Speed = 5;
  Uni->AngleSpeed = 5;
  Uni->At = VecSet1(0);
  Uni->Dir = VecNormalize(VecSubVec(Uni->At, Uni->CamLoc));
  Uni->Right = VecNormalize(VecCrossVec(Uni->Dir, VecSet(0, 1, 0)));
} /* End of 'ND4_UnitInit' function */

/* Ctrl unit inter frame events handle function.
 * ARGUMENTS:
 *   - self-pointer to unit object:
 *       nd4UNIT_CTRL *Uni;
 *   - animation context:
 *       nd4ANIM *Ani;
 * RETURNS: None.
 */
static VOID ND4_UnitResponse( nd4UNIT_CTRL *Uni, nd4ANIM *Ani )
{
  if (Ani->Keys['S'] || Ani->Keys['W'])
  {
    Uni->CamLoc = VecAddVec(Uni->CamLoc, VecMulNum(Uni->Dir, Ani->GlobalDeltaTime * Uni->Speed * (Ani->Keys['W'] - Ani->Keys['S'])));
    Uni->At = VecAddVec(Uni->At, VecMulNum(Uni->Dir, Ani->GlobalDeltaTime * Uni->Speed * (Ani->Keys['W'] - Ani->Keys['S'])));
  }
  if (Ani->Keys['A'] || Ani->Keys['D'])
    Uni->CamLoc = VecAddVec(Uni->CamLoc, VecMulNum(Uni->Right, Ani->GlobalDeltaTime * Uni->Speed * (Ani->Keys['D'] - Ani->Keys['A'])));
  
  if (Ani->Mdz)
    Uni->CamLoc = VecAddVec(Uni->CamLoc, VecMulNum(Uni->Dir, Ani->GlobalDeltaTime * Uni->Speed * Ani->Mdz * 0.01));

  if (Ani->Keys[VK_LBUTTON])
    Uni->CamLoc = PointTransform(Uni->CamLoc, MatrRotateY(-Ani->Keys[VK_LBUTTON] * Ani->GlobalDeltaTime * Uni->AngleSpeed * Ani->Mdx * 30));

  if (Ani->Keys[VK_DOWN] || Ani->Keys[VK_UP])
  {
    Uni->CamLoc.Y += Ani->GlobalDeltaTime * Uni->Speed * (Ani->Keys[VK_UP] - Ani->Keys[VK_DOWN]) * 18;
    Uni->At.Y += Ani->GlobalDeltaTime * Uni->Speed * (Ani->Keys[VK_UP] - Ani->Keys[VK_DOWN]) * 18;
  }
  if (Ani->Keys[VK_RIGHT] || Ani->Keys[VK_LEFT])
  {
    Uni->CamLoc = VecAddVec(Uni->CamLoc, VecMulNum(Uni->Right, (Ani->Keys[VK_RIGHT] - Ani->Keys[VK_LEFT]) * 18 * Ani->GlobalDeltaTime));
    Uni->At = VecAddVec(Uni->At, VecMulNum(Uni->Right, (Ani->Keys[VK_RIGHT] - Ani->Keys[VK_LEFT]) * 18 * Ani->GlobalDeltaTime));
  }
  if (Ani->JX == 1 || Ani->JX == -1)
    Uni->CamLoc = VectorTransform(Uni->CamLoc, MatrRotateY(Ani->GlobalDeltaTime * Uni->AngleSpeed * Ani->JX * 30));

  if (Ani->JY == 1 || Ani->JY == -1)
    Uni->CamLoc = VectorTransform(Uni->CamLoc, MatrRotateX(Ani->GlobalDeltaTime * Uni->AngleSpeed * Ani->JY * 30));

  if (Ani->JZ == 1 || Ani->JZ == -1)
    Uni->At.Y = Uni->At.Y - Ani->GlobalDeltaTime * Uni->Speed * Ani->JZ * 3;
  if (Ani->JR == 1 || Ani->JR == -1)
    Uni->At.X = Uni->At.X + Ani->GlobalDeltaTime * Uni->Speed * Ani->JR * 3;


  if (Ani->JBut[6] && Ani->JBut[7])
  {
    Uni->CamLoc.Z -= Ani->GlobalDeltaTime * Uni->Speed;
    Uni->At.Z -= Ani->GlobalDeltaTime * Uni->Speed;
  }
  else if (Ani->JBut[4] && Ani->JBut[5])
  {
    Uni->CamLoc.Z += Ani->GlobalDeltaTime * Uni->Speed;
    Uni->At.Z += Ani->GlobalDeltaTime * Uni->Speed;
  }
  
  if (Ani->JBut[6] || Ani->JBut[7])
  {
    Uni->CamLoc.X += Ani->GlobalDeltaTime * Uni->Speed * (Ani->JBut[7] - Ani->JBut[6]) * 0.5;
    Uni->At.X += Ani->GlobalDeltaTime * Uni->Speed * (Ani->JBut[7] - Ani->JBut[6]) * 0.5;
  }

  if (Ani->JBut[0] || Ani->JBut[2])
  {
    Uni->CamLoc = VecAddVec(Uni->CamLoc, VecMulNum(Uni->Dir, Ani->GlobalDeltaTime * Uni->Speed * (Ani->JBut[0] - Ani->JBut[2]) * 3));
    Uni->At = VecAddVec(Uni->At, VecMulNum(Uni->Dir, Ani->GlobalDeltaTime * Uni->Speed * (Ani->JBut[0] - Ani->JBut[2]) * 3));
  }
  if (Ani->JBut[4] || Ani->JBut[5])
  {
    Uni->CamLoc.Y += Ani->GlobalDeltaTime * Uni->Speed * (Ani->JBut[5] - Ani->JBut[4]) * 0.5;
    Uni->At.Y += Ani->GlobalDeltaTime * Uni->Speed * (Ani->JBut[5] - Ani->JBut[4]) * 0.5;
  }

  if (Ani->JBut[3])
  {
    Uni->CamLoc = PointTransform(Uni->CamLoc, MatrRotateY(Ani->GlobalDeltaTime * Uni->AngleSpeed * 30));
    Uni->At = PointTransform(Uni->At, MatrRotateY(Ani->GlobalDeltaTime * Uni->AngleSpeed * 30));
  }
  if (Ani->JBut[1])
  {
    Uni->CamLoc = PointTransform(Uni->CamLoc, MatrRotateY(Ani->GlobalDeltaTime * Uni->AngleSpeed * -30));
    Uni->At = PointTransform(Uni->At, MatrRotateY(Ani->GlobalDeltaTime * Uni->AngleSpeed * -30));
  }

  if (Ani->JButClick[8])
    ND4_Anim.IsPause = !ND4_Anim.IsPause;

  if (Ani->KeysClick['N'])
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  if (Ani->KeysClick['B'])
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);


  Uni->Dir = VecNormalize(VecSubVec(Uni->At, Uni->CamLoc));
  Uni->Right = VecNormalize(VecCrossVec(Uni->Dir, VecSet(0, 1, 0)));
  ND4_RndCamLoc = Uni->CamLoc;
  ND4_RndCamRight = Uni->Right;
  ND4_RndCamAt = Uni->At;
  ND4_RndCamDir = Uni->Dir;
  ND4_RndCamUp = VecSet(0, 1, 0);
} /* End of 'ND4_UnitResponse' function */

/* Ctrl unit inter frame events handle function.
 * ARGUMENTS:
 *   - self-pointer to unit object:
 *       nd4UNIT_CTRL *Uni;
 *   - animation context:
 *       nd4ANIM *Ani;
 * RETURNS: None.
 */
static VOID ND4_UnitClose( nd4UNIT_CTRL *Uni, nd4ANIM *Ani )
{
} /* End of 'ND4_UnitResponse' function */

/* Ctrl unit render function.
 * ARGUMENTS:
 *   - self-pointer to unit object:
 *       nd4UNIT_CTRL *Uni;
 *   - animation context:
 *       nd4ANIM *Ani;
 * RETURNS: None.
 */
static VOID ND4_UnitRender( nd4UNIT_CTRL *Uni, nd4ANIM *Ani )
{
  ND4_RndCamSet(Uni->CamLoc, Uni->At, VecSet(0, 1, 0));
} /* End of 'ND4_UnitRender' function */

/* Unit ctrl creation function.
 * ARGUMENTS: None.
 * RETURNS:
 *   (nd4UNIT *) pointer to created unit.
 */
nd4UNIT * ND4_UnitCreateCtrl( VOID )
{
  nd4UNIT *Uni;

  if ((Uni = (nd4UNIT *)ND4_AnimUnitCreate(sizeof(nd4UNIT_CTRL))) == NULL)
    return NULL;

  /* Setup unit methods */
  Uni->Init = (VOID *)ND4_UnitInit;
  Uni->Response = (VOID *)ND4_UnitResponse;
  Uni->Render = (VOID *)ND4_UnitRender;
  Uni->Close = (VOID *)ND4_UnitClose;

  return Uni;
} /* End of 'ND4_UnitCreateCtrl' function */


/* END OF 'unit_ctrl.c' FUNCTION */